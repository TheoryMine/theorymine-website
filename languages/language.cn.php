<?php
$lang = array (
  'txt_charset'                 => 'utf-8',
  'txt_lang'                     => "Chinese",
  'lang'						    => "cn",

  //page_overview

  'overview_title'  => 'TheoryMine为您创造了给全新数学定理定制个性化名字的机会。新奇的礼物，不是么？',
  'overview_tagline' => '您可以自主命名一个新的数学定理。比如用您的爱人，老师，朋友，自己，甚至宠物为它们命名。这些定理由目前所知世界上最先进的计算机定理证明程序生成，它基于人工智能，构思出新的数学定理。',
  'overview_see_example' => '查看证书样例',
  'overview_you'=> '您',
  'overview_we'=> '我们',
  'overview_they' => '他们',
  'overview_you2'=> '构思名字！',
  'overview_we2'=> '探寻数学定理！',
  'overview_they2' => '得到一个惊喜',
  'overview_get_started' => '永恒的起航点:',
  'overview_choose' =>'输入您构思出来的名字',
  'overview_preview' => '预览您的定理！',
  'overview_eg' => '比如，我爱我家定理，小李子定理',

  //page_discover

  'discover_title' => '命名一个新的数学定理:',
  'discover_15'=> '仅15英镑',
  'discover_imagetag' => '*这只是一个预览，并非您将得到的定理。',
  'discover_part1' => '  通常我们的机器数学专家需要48小时来探寻您的数学定理。一旦新的定理被发现，我们就会以邮件的方式告知您：您的定义已经将就绪。接着您就可以登录我们的系统来下载证书',
  'discover_see_ex' => '参阅证书模板',
  'discover_part2' =>'在订购您的数学定理后，您还购买其他的定理相关的礼品。当您收到您的定理后您可以通过点击在您的账户页面里的定理名旁边的“礼品中心”按钮来继续。' ,
  'discover_part3' => '注意：如果您想使用特定的邮箱来接受您的定理，请您确保使用该地址来注册和登录我们的系统。否则，我们将把定理发送到您的Paypal的邮箱地址。',
  'discover_choose' => '选择您的定理名字:',
  'discover_eg' => '例如： Tom定理',
  'discover_tc1' => '我已阅读并同意条款和条例',
  'discover_tc2' => 'TheoryMine条款条例',
  'discover_sub1' => '当您提交您的订单时，您将接收到您的用户名和密码来',
  'discover_sub2' => '我们的网站。您可以随时登录来查看您订单的状态，您命名的数学定理以及下载您数学定理的证书。',
  'discover_sub3' => '数学定理由机器人数学家来探寻，我们尽我们所能来确保这些定理是未曾被发表的，同时我们保证每一条新发现的数学定理都是我们数据库中不存在的。在极少数的情况下，我们不排除有先前的文章发布了相同的数学定理的情况，如发生该情况我们将给您更换一个新的数学定理，再额外赠送一条新的数学定理。欲知更多我们如何确保我们发现的数学定理是未被发现过的，',
  'discover_choose2' => '输入您构思的定理名',
   'discover_voucher' => '请输入折扣券',
  'discover_confirm' => '确定',
  'discover_voucher_valid' => '限时特价优惠',
  'discover_voucher_invalid' => '无效优惠券',
  'discover_5'=> '仅5英镑',
  //faq

  'faq_title' => '常见问题:',
  'faq_about' =>'关于我们',
  'faq_sec1' => '关于您的购买',
  'faq_sec2' => '关于TheoryMine如何运作',
  'faq_q1' => '我能从THEORYMINE购买到什么？',
  'faq_q2' => '购买的流程是什么？',
  'faq_q3' => '当有新的相关产品推出时，我还能购买与我已购买的数学定理相关的商品么？',
  'faq_q4' => '我能自己选择我要购买哪个数学定理吗？',
  'faq_q5' => '当我的订单生效后，我还能更改已购买的数学定理的名字吗？',
  'faq_q6' => '我能给数学定理起什么样名字',
  'faq_q7' => '我该如何付款？有哪些支付方式？',
  'faq_q8' => '为什么我的数学定理在你们承诺的时间内还没有发给我？',
  'faq_q9' => '为什么我的证书的格式显示不正确？',
  'faq_q10' => '什么是数学理论？',
  'faq_q11' => '什么是数学定理？',
  'faq_q12' => '什么是递归定义？',
  'faq_q13' => 'TheoryMine生成的是什么样的数学定理？',
  'faq_q14' => '我如何确认关于我数学定理的证明是正确的？',
  'faq_q15' => '自动生成数学定理可能吗？',
  'faq_q16' => '我该如何确认我的数学定理是你们原创的？',
  'faq_q17' => '我该如何确认我的数学定理不是显而易见的？',
  'faq_q18' => '我该如何确认我的数学定理不是显而易见的？',
  'faq_q19' => '我被什么官方组织授权有用命名权',
  'faq_q20' => '为什么你能声明数学定理能永久存在？',
    'faq_a1' => '您可以购买到新发现的数学定理的命名权。您将会收到一份PDF格式证书文档，文档内记载这该数学定理是如何被发现的。 这可以成为一份馈赠朋友的新奇礼物，或者书悬挂在书房内尽显书香门地证书，又或是吹牛利器？将来我们还计划推出和您的数学定理更多的相关产品，例如T恤以及鼠标垫等。如果您的这些新奇产品推出前，已经购买了您的数学定理，您仍然可以向我们购买到和您拥有的数学定理相关的产品。',
  'faq_a2' => '如果您还未在TheoryMine注册过，您将收到用户名和密码来登录我们官方网站系统的账号，使用该账号可以查看您的购买记录以及状态。通常在您购买的48小时内，我们的智能数学系统将为探寻属于您的数学定理。当数学定理被发现的时候，系统会自动发送提示邮件告知您。这时，您就可以登录我们的官方网站点击“查看证书”来获得相关信息。',
  'faq_a3' => '当然可以！我们正计划推出该功能，不久您就用可以用您的账号来登录我们的官方网站后，在线购买这些与您的数学定理相关的小礼包，体恤衫以及马克杯。',
  'faq_a4' => '不行，由于我们的系统是实时探寻新的数学定理，您将会获得最新被被系统发现的那个数学定理。',
  'faq_a5' => '不，这也正是我们产品的魅力所在。一旦您为一个最新发现的数学定理命名，该定理将永远使用您给的名字。<br> 但是如果您在您的订单仍未生效前想更换名字，您可以马上发邮件到support@theorymine.co.uk和我们联系。',
  'faq_a6' => '在不具有侮辱，亵渎，色情，违反公共道德，具有煽动种族仇恨或者恐怖主义色彩的前提下，您可以给您的数学定理器任意您喜欢的名字。',
  'faq_a7' => '您可以通过paypal的支付，这些第三方将会对我们保密您的支付信息，因此我们是不可能获得任何您的银行卡号或者信用卡信息。',
  'faq_a8' => '这里首先我们请您注意，如果您在支付时没有登录我们官方网站的账号。我们的系统将默认把您的数学定理相关信息发送到和paypal相关联的电子邮箱里。此时，您可以通过我们给您的paypal邮箱中确认信中的用户名和密码来登录我们的官方网站。如果您在我们承诺的时间内未收到确认信，请参阅<a href="http://www.theorymine.co.uk/?go=faq#process">该链接</a>。或者，您收到确认信后，无法通过“查看证书”来获取您的数学定理的证书，请您及时发送电子邮件到support@theorymine.co.uk 和我们联系，我们将在第一时间为您解决问题。',
  'faq_a9' => '并不是所有的PDF阅读器都能正确的显示使用在证书上的数学符号，这将导致您的证书在您的电脑上显示不正确。如果你使用Adobe Reader (免费的PDF浏览器 <a href="http://get.adobe.com/reader/">下载地址</a>)，证书将可以正常显示。',
  'faq_a10' => '从学校我们学到了各种各样的数学，整数，分数，小数，集合以及向量等数学对象。一些关于数学对象的例子可以点击<a href="http://www.theorymine.co.uk/?go=certificate_example#data-type">这里</a>。首先，我们研究并发现各种新的数学对象，这些数学对象的潜在数量是无限的。在学校我们把一些<a href="http://www.theorymine.co.uk/?go=certificate_example#functions">函数</a>用于数字，比如加减乘除。其次我们研究并发现各种可以被用于这些新的数学对象的新函数。同样的，这些新函数的潜在数量也是无限的。一个数学理论就是由一个或者多个数学对象加上一些相关的函数所组成的。',
  'faq_a11' => '<a href="http://www.theorymine.co.uk/?go=certificate_example#theorem">数学定理</a>一个已被证明的数学表达式。这些在同一个数学理论的数学定理及其证明组成了数学公理。一个证明就是数学证明流程，是由一个数学公理出发，使用数学公式将其转化成数学定理的过程。在这个证明过程中所有非数学公理的表达式都紧跟着之前的数学表达式。在TheoryMine发现的数学理论中的所有的数学公理都采用递归式方法来定义。',
  'faq_a12' => '<a href="http://www.theorymine.co.uk/?go=certificate_example#recursion">递归</a>是一种在计算机程序中常用的数学技巧。在递归定义中，递归函数的值通过调用自身并传入比当前值小的参数来定义。随着参数的值逐渐减小，该方法可以保证求值的过程是可终止的，而非无限循环的自我调用。TheoryMine采用递归的方式来定义数学理论中用到的新的输入和输出的类型。他们被称为递归对象。',
  'faq_a13' => 'TheoryMine证明函数的性质，比如加法函数中，加数以及被加数的顺序是不重要的，2+3 等于 3+2。 然而，减法函数就不一样了，2-3并不等于3-2，TheoryMine研发出一些像加法一样的数学函数，并研究一些类似参数的顺序是否重要等数学函数的性质。一些函数是其他一些函数的逆运算。比如，加法和减法，加上一个数后减去同样一个数，该数将不变。TheoryMine也发掘一些函数的互逆性质。这些都是TheoryMine所涉及的经典的数学定理。',
  'faq_a14' => '在TheoryMine背后支持它的计算机程序的庞大而复杂的。和其他大型程序一样，该程序也会存在漏洞，但是大部分这些可能存在漏洞的程序块并不参与选择数学理论，证明数学定理和生成数学证明。构造证明的核心程序模块是一个精简的，受过检验的以及具有高可靠度的程序。该模块仅有使用之前已被证明的定理和理论。因此生成一个错误结论的可能性是微乎其微的。',
  'faq_a15' => 'TheoryMine是基于在爱丁堡大学，剑桥大学以及慕尼黑大学的多年的世界顶级的在自动推理和人工智能的研究成果。它使用数学理论和数学定理的语法来生成候选对象，然后过滤掉那些具有明显错误的和无价值的对象，接着使用自动推理技术来证明剩下的对象。',
  'faq_a16' => 'TheoryMine的程序构建全新的数学理论，这些理论之前并未被任何人使用递归函数和递归对象定义过。因此从定义上可以保证，所有基于新的数学理论上数学定理是原创的。',
  'faq_a17' => '数学定理不是显然意见有两层含义：首先，一些数学理论存在不一致性。比如在那些数学理论中的数学公理是相互矛盾的。在这种情况下，所有的数学表达式都是数学定理，显然，这不是我们想要的。然而作为一个完善的数学结论，数学理论仅由递归定义而来，并且是具有内在的一致性。所有的TheoryMine的数学理论都遵循这种框架。从这个角度来讲，您的数学定理不是显而易见的。其次，如果一个数学定理不是显而易见的，则它不能通过直接由简单的演算来推导。尤其不能通过简单的通过改写公式从其他的一些已知的数学定理来转化来的。关于这个问题的更多解释可以查看<a href="#interesting">我的数学定理有价值吗？</a>。',
  'faq_a18' => 'TheoryMine使用一些的过滤器来避免生成无价值的数学定理，当然，这些定理也不可能为您赢得诺贝尔奖。特别要声明的是，这里我们谈论的“价值”是有一定规范的，它最早在 <a href="http://www.springerlink.com/content/bk711q2u247mr967">Conjecture Synthesis for Inductive Theories (Journal of Automated Reasoning)</a> 所提出，接着在 <a href="http://www.springerlink.com/content/m885557421m7418m">Scheme-Based Synthesis of Inductive Theories (LNCS, Volume 6437)</a> 被进一步完善。专业角度来说，一个有价值的数学定理应该具不能使用现有的数学定理作为转化公式来转化出来，换句话说，单纯的直接靠符号转化是证明不出这些新的数学定理的。',
  'faq_a19' => '作为一直以来的传统习惯，一个数学定理的发现者拥有给它命名的权利。TheoryMine作为发现者把这种权利授予您。',
  'faq_a20' => '数学定理一旦被证明了就永久存在了。 因为证明的过程是采用严谨的数学演绎法来推论，不存在不确定性。同时，数学定理作为一种抽象的存在是不会消失的，即使“一颗恒久远”的钻石在高温中也面消失，而我们的数学定理不会。',

  //about

  'about_title' => '关于我们：',
  'about_p1' =>'Theory<font color="#b4975a">Mine</font>专注于数学定理的<a href="http://dream.inf.ed.ac.uk/events/automatheo-2010/">自动探索与发现</a>  ：我们研发人工智能技术，并将其用于探索新的数学相关概念和证明的自动化。通过提供一些有趣的数学定理的证明应用，(例如 <a href="?go=discover">命名新的数学定理</a>)，来支持逻辑推理自动化技术的相关应用。我们正致力于可用于改善软件可靠性和安全性的验证工具，以及一些能简易新的数学相关概念的探寻的工具。',
  'about_p2' =>'我们的软件基于国际社区的数十年的自动化推理的研究，尤其是<a href="http://itp2011.cs.ru.nl/ITP2011/Home.html">交互式定理证明（interactive theorem proving）</a> 以及 <a href="http://cade23.ii.uni.wroc.pl/">自动推理（automated deduction）</a>. 该研究成果得到更加广泛的应用及肯定。',
  'about_p3' =>'TheoryMine由一群在<a href="http://www.ed.ac.uk/">爱丁堡大学</a> <a href="http://www.ed.ac.uk/schools-departments/informatics/">信息学院</a>的研究人员组建:',
  'about_alan' => '爱丁堡大学信息学院自动推理方向教授，英国计算学会副会长（British Computing Society）。智能系统及其应用中心（Centre for Intelligent Systems and their Applications）的会员。',
  'about_fla' => '毕业于爱丁堡大学 人工智能与数学研究方向（Artificial Intelligence and Mathematics）。',
  'about_lucas' => '爱丁堡大学数学推理研究组（Mathematical Reasoning Group）的高级研究员，该研究组隶属于智能系统及其应用中心（Centre for Intelligent Systems and their Applications）。Lucas是TheoryMine的软件研发核心人员。',
  'about_moa' => ' 现就任于信息学院在意大利维罗纳大学的博士后工作。于爱丁堡大学数学推理研究组获得的博士学位。',
  'about_roy' => '爱丁堡大学信息学院高级研究员，智能系统及其应用中心（Centre for Intelligent Systems and their Applications）会员。',

  //products

  'gift_title'=>'礼品包:',
  'gift_p1' =>'当您命名了一个定理的时候，您就为那个定理赋予了永恒的名称!',
  'gift_p2' =>'一个数学定理的发明需要大量的工作以及聪明的思维。这就赋予了发现者命名这些定理的权利，比如Gauss, Fermat和Pythagoras。现在这种将自己的名字与那些数学家巨人的名字铭刻在一起的梦想将成为现实。首先必须感谢能自动生成并证明数学定理的系统。我们保证我们的定理是唯一，因为他们是从唯一的数学理论中生成的。数学归纳法在设计层面上就保证了数学理论的一致性，并且不是伪真实的。',
  'gift_p3' =>'您可以命名一个定理，并可以决定是否一个有其具体信息的证书，发表在我们的期刊上，甚至是打印在一间T恤上。',
  'gift_h1' =>'命名一个定理 + PDF证书: <font color="#b4975a">15磅 </font>',
  'gift_h2' =>'其他礼品:',
  'gift_h1_1' => '当您购买了一个定理后，您将收到 :',
    'gift_li1_1'=>  '一份有您购买的定理和您的命名的彩色可打印的PDF证书。 <a href="?go=certificate_example" target="_black">预览</a>',
  'gift_li1_2'=>  '一份可以帮助您理解定理的手册',
  'gift_li1_3'=>  '一个用于登录我们系统来查看定理这证书的用户名和密码',
  'gift_h1_2' => '此外您可以购买任何与您的定理相关的商品： ',
  'gift_li2_1'=>  'T恤',
  'gift_li2_2'=>  '马克杯',
  'gift_li2_3'=>  '鼠标垫',
  'gift_end' => '在购买这些礼品前，请先购买数学定理。在您收到订立时，您可以登录我们的系统到<a href= "?go=login">您的账户</a>，点击在您定理的名字的旁边“礼品中心”。',

  //Testimonials

  'tes_title' => '见证:',
    'tes_p1' => ' ”这的的确确捕获了我的想象力，我很高兴能作为TheoryMine的第一个顾客。这真是一个新颖有趣的产品，它为苏格兰人工智能的应用领域开辟了新篇章。”',
  'tes_p2' => '“我时常相想象要是能证明出一个定理，并用自己的名字来让它永远记在数学的史书上是种怎样的感觉。我一度认为这个梦想不可能实现了，因为我成为科学领域的作家。但是现在Aron\'s theorem成真了。”',
  'tes_p3' => '“这是一个让人吃惊的创新！”',
  'tes_p4' => '“只要15磅就能在TheoryMine买个名字，比去Pythagoras改名字还便宜20磅。”',
  'tes_p5' => '“今年的礼物是这个巧妙的命名（甚至可以说是天才的想法）！”',
  'tes_p6' => '“开始享受数学带来的快乐永远不会太早，这是个一辈子的礼物。”',
  'tes_p7' => '点击查看BBC\'s Material World的采访 ',


   //Abuse

   'abuse' => '感谢您对于该系统滥用的回馈。我们将尽我们所能调查该问题。',


   //Bad_cert_id

   'badid_title' => '无效的证书ID ',
   'badid_p' => '您输入的证书ID不完整或者不正确。清宁确认宁德证书链接。如果您仍继续遇到该问题请',


   //Cancellation

   'canc_title' => '取消条例',
   'canc_p' => '由于您购买的TheoryMine的数学定理是专门为您定制的，所以您可以在产品未被产生前的任意时间取消。您只需要发邮件到 support@theorymine.co.uk ，我们将取消订单并退款给您。如果您的产品已经开始受理，那么您将无法取消订单并得到退款。如果您对您的定理不满意（比如定理不是唯一的），那么您可告知我们，我们将乐意退款给您。',


   //Timeout

   'timeout_title' => '您已经成功退出。',
   'timeout_p1' => '在',
   'timeout_p2' => '分钟的无操作或者试图访问限制页面，您将被系统自动退出。如果您想继续，请点击 <a target="_blank" href="?go=login">重新登录</a>; 该链接将打开一个新窗口然后您就可以重新载入页面了。',


  //Certificate_example

  'certex_title' => '证书样品说明',
  'certex_p1' => '如下显示的是TheoryMine生成的证书样品。点击图片中的表达式即可查看表达式具体含义。',
  'certex_q1' => '如何理解证书？<br><br> 概述',
  'certex_a1' =>'<p> 2010年4月15日，BBC广播4台的科学杂志节目Material World采访了我们，我们特意为记者Quentin Cooper生成了一条数学定理。该证书和原先授予Quentin的有些细微不同。我们已经更新了样本证书的样板。此外，我们也已经规范化了数学表达式命名规则。</p><p> 紧接在定理名Quentin\'s Theorem后的依次是：数学对象的定理<em> T</em> ; 数学函数的定义, <em> f<sub>&#945</sub></em> ;以及数学定理的申明。</p>
<p> 一种联想数学对象<em> T</em> 的方式是：把它想象成具有不同颜色的4个自然数全集的拷贝 0, 1, 2, 3, ..., 红色，蓝色，绿色和黄色: <span
style="color:#FF0000">0, 1, 2, 3, ...</span>, <span
style="color:#0000FF">0, 1, 2, 3, ...</span>, etc.  每个
<em> T</em>  的成员有个数值和颜色值。  <em> f<sub>&#945</sub></em>
是可应用于这些数的加法函数。 该函数的参数是两个带颜色的数值，并返回一个值为两参数值的和的数值并带有第 <em> 二 </em> 参数的颜色。</p>
<p> 值得注意的是该加法和常规意义上的加法是不同的, <em> f<sub>&#945</sub></em>  不满足
交换律, 即返回值依赖于参数的 <em> 顺序</em>  。 例如,
<em> f<sub>&#945</sub>(<span style="color:#FF0000">1</span>, <span style="color:#0000FF">2</span>)=
<span style="color:#0000FF">3</span></em>  但
<em> f<sub>&#945</sub>(<span style="color:#0000FF">2</span>, <span style="color:#FF0000">1</span>)=
<span style="color:#FF0000">3</span></em> 。
返回值的数值是相同的，由于颜色值依赖于第二个参数。所以颜色值就不一样了。</p>
<p> 然而，当三个数相加时，前两个参数的顺序就无关紧要了。因为返回值的颜色值依赖于第三个参数而不是前两个参数。例如：
<em>
f<sub>&#945</sub>(<span style="color:#FF0000">1</span>,
	f<sub>&#945</sub>(<span style="color:#0000FF">2</span>,<span style="color:#00FF00">3</span>)) =
f<sub>&#945</sub>(<span style="color:#0000FF">2</span>,
	f<sub>&#945</sub>(<span style="color:#FF0000">1</span>,<span style="color:#00FF00">3</span>))
</em>  左边和右边都等于 <span style="color:#00FF00">6</span>。
该性质的泛化就是Quentin\'s Theorem, 比如, 一种受限的交换律的变体。</p>
<p> 现在我们来从专业角度来介绍下证书。所有技术名词被定义在位于页尾的<a href="#glossary">术语表</a> 中。</p>',
'certex_q2' => '递归入门指南',
'certex_a2' => '<p><em> T</em> 和<em> f<sub>&#945</sub></em> 都是用 <em> 递归</em> 来定义。该定义方式中的定义表达式中包含被定义主体。听起来似乎是一种死循环的定义模式。其实不然。考虑如下的<em> 自然数</em> 的递归定义, 比如非负整数0, 1, 2, 3, .... </p> <p><center><em> N = 0 | s(N) </em> </center></p> <p> 其中 <em> s</em>  被称为<em> 后继函数</em> 。该定义生成了采用如下表现形式的自然数 <em> 0, s(0), s(s(0)), s(s(s(0))), ...</em> ,每次使用函数<em> s</em> 就使数值加一 。该表现形式源于数学家<a href="http://en.wikipedia.org/wiki/Peano_axioms">Giuseppe Peano (1858-1932)</a>。 递归定义由；两部分组成：基础范例( base case) <em> 0</em>  和一个进阶范例(step case <em> s(N)</em> 。 每一个自然数都相对于其中一种定义模式。其中进范例的定义中包含<em> N</em> ，即被定义主体。把这想象成螺旋状而非圆形。<em> 0</em> 是螺旋的中心点，每次使用 <em> s</em> 就使得的螺旋往外加一圈。 <em> 0</em> 和<em> s</em> 被称为<em> 构造函数</em> ，因为他们被用于构造新数学对象的类型，例如四色整数。注意构造函数是<em> 有意</em> 不定义的。 他们被视为数学对象的基础元素并被用于定义其他的数学对象和函数，比如+。定义会在某些点停止继续展开，这些点就是构造函数。 </p>

<p>布尔值, <em> 真(true)</em>  和 <em> 假(false)</em> , 可以通过退化形式的的递归来定义, 该定义式由两个基础范例（base case）组成且没有进阶范例（step case）: <em> B = true | false</em> 。</p>

<p> 我们采用<em> B</em>  和 <em>  N</em> 作为定义新的递归方式定义的数学对象的名称代表，比如
在我们之前例子中的<em>  T</em> 。</p>

<p>加法函数<em> +</em> 也可以通过递归来定义。它采用两个为<em> N</em> 的成员作为的递归的参数并返回一个输出。同样的它页有一个基础范例和进阶范例</p>
<p><center><strong>Type:</strong> <em>  + : N &times; N &rarr; N </em>  </center></p>
<p><center><strong>Base case:</strong> <em>  0+y = y </em> </center></p>
<p><center><strong>Step case:</strong> <em>  s(x)+y = s(x+y) </em>  </center></p>

<p> type行定义了加法函数 + 有两个输入参数和一个输出返回。 base case和step case行一起构成了加法的递归定义。递归发生在变量<em> x</em> ，即第一个参数。在进阶范例的定义表达式中也包含了被定义的主体，即+。同样的这不是一个死循环定义，而是螺旋型， 不同的是这次是向内螺旋。从某个<em> x</em> 的值开始， 比如 <em> s(s(o))</em> ，然后进阶范例就可以被换写，首先从<em> s(s(0))+y</em> 到<em> s(s(0)+y)</em> ，接着成为
<em> s(s(0+y))</em> 。然后基础范例的定义就可以被用来换写
成 <em> s(s(y))</em> 到这里换算结束。
请注意在进阶范例的的特殊的组织方式：相对于头部表达式中的 <em> x</em> , 主体表达式中的 <em> x</em> 被逐步转换成更小的值的范围的定义方式。<em> N</em> 的定义方式是<em> 良基</em> ，该属性保证了该类型的成员的值不能无限减小，任意的值在减少后最终会终止于$0$。这确保了加法函数的演算重重能够终止。即，进阶范例的使用次数是有穷的，最终基础范例将可被应用，此时演算结束。为了将区别出这种函数和构造函数( <em> 0</em> 和<em> s</em> )，他们被称为<em> 已定义函数</em> 。',
	'certex_q3' => '定义四色数',
	'certex_a3' => '<p> 我们证书引入了一个新的数学对象<em> T</em> 的定义，四色数。 <em> T</em> 是通过
<a href="#recursion">递归</a> 来定义的：</p>

<p><center><em>  T = C<sub>a</sub>(B,B) | C<sub>b</sub>(T) </em> </center></p>

<p> 其中 <em> C<sub>a</sub></em> 和<em> C<sub>b</sub></em> 是新的构造函数。
<em>  C<sub>a</sub></em>  是基础构造函数，因为它的定义式中并不包含任何<em> T</em> 。这可以类比到在
<em> N</em> 定义中的0，不同的是它有两个输入参数。两个输入参数都是
<em> B</em> 的成员，比如他们可能是两个布尔值的:
<em> true</em>  and <em> false</em> 之一。 因此共有四种实例化它的可能<em> C<sub>a</sub></em> : <em> C<sub>a</sub>(true,true)</em> ,
<em> C<sub>a</sub>(true,false)</em> , <em> C<sub>a</sub>(false,true)</em> 以及
<em> C<sub>a</sub>(false,false)</em> , 因此共有四种版本的0值。从如上的例子中我们可以想象成四种不同颜色的0。例如， <em> C<sub>a</sub>(true,true)</em>  可想成<span style="color:#FF0000">0</span>， 而<em> C<sub>a</sub>(true,false)</em>  就是
<span style="color:#0000FF">0</span>。 </p>

<p> <em> C<sub>b</sub></em> 是一个进阶构造函数，因为它有<em> T</em> 出现在定义式的输入中。
这可以被类比成<em> N</em> 里的<em> s</em> 。<em> s</em>  主要的不同是
<em> C<sub>b</sub></em> 可以被应用不任意不同的基础范例的参数上。我们可以联想<em> C<sub>b</sub></em> 为颜色值的维持。 例如，<em> C<sub>b</sub>(C<sub>b</sub>(C<sub>a</sub>(true,true)))</em> 有
<span
style="color:#FF0000">0</span> 作为它的参数，我们可以视其为<span
style="color:#FF0000">2</span>。</p>

<p>正如<em> 0</em> 和<em> s</em> ， <em> true</em> 和
<em> false</em> ， 和新的构造函数<em> C<sub>a</sub></em> 和
<em> C<sub>b</sub></em>  都属于未定义的基础值。</p>',
	'certex_q4' => '定义四色加法',
	'certex_a4' => '<em> f<sub>&#945</sub></em> 是一个通过<a href="#recursion">递归</a>实现的已定义函数，定义如下：</p>

<p><center><strong>Type:</strong> <em>  f<sub>&#945</sub> : T &times; T &rarr; T </em>  </center></p>
<p><center><strong>Base case:</strong> <em>  f<sub>&#945</sub>(C<sub>a</sub>(x,y),z) = z </em>  </center></p>
<p><center><strong>Step case:</strong> <em>  f<sub>&#945</sub>(C<sub>b</sub>(x),y) = C<sub>b</sub>(f<sub>&#945</sub>(x,y)) </em>  </center></p>
</ul>

<p>和之前定义的加法比较一下，就会发觉，本质上他们是一样的<em> f<sub>&#945</sub></em>  另一种版本的加法</p>

<p> 想知道为什么 <em> f<sub>&#945</sub></em>  的返回值有着和第二个参数相同的颜色值？试想下第一个基础范例， <em> f<sub>&#945</sub></em> 的第一非参数的颜色是某种颜色的0,
<em> C<sub>a</sub>(x,y)</em> ，但是无论它是什么颜色的，保留下来的都是第二个参数<em> z</em> 的颜色。 </p>

<p> 现在我们来看进阶范例的定义
<em> f<sub>&#945</sub></em> 。 假设我们已经推论出<em> f<sub>&#945</sub>(x,y)</em> 的输出的颜色和第二个参数<em> y</em> 相同。 因为 <em> C<sub>b</sub></em>  能维持颜色的属性， 接着<em> f<sub>&#945</sub>(C<sub>b</sub>(x),y)</em>  的颜色和 <em> y</em> 一致。 这种从 <em> f<sub>&#945</sub></em>  的第一个参数<em> C<sub>a</sub>(x,y)</em> 螺旋式的一层一层向外推理出
<em> C<sub>b</sub></em>  ， 最终到任意
<em> T</em> 里的一个值。 这被称为<em> 数学归纳法证明</em> 。 TheoryMine采用这种技术来证明生成的定理。 </p>。',
	'certex_q5' => '证明 Quentin\'s Theorem',
	'certex_a5' => '<p> 在证书上， Quentin\'s Theorem 被声明为"通过对<em> y</em> 使用数学归纳法证明"。 这该如何理解呢？ </p>

<p> <em> 数学归纳法</em>  紧密的和 <a
href="#recursion">递归</a>联系在一起。 定理是由 <a
href="#functions">递归定义的函数</a> 用在 <a
href="#data-type">递归定义的对象</a>上生成的， 例如Quentin\'s theorem， 就是用数学归纳法证明的。首先，先选择一个归纳变量。在这个例子里是<em> y</em>  - 尽管， 在Quentin\'s Theorem里<em> x</em>  和<em> y</em> 是对称的， 我们可以等价的选择
<em> x</em> 。 递归变量遍历一些递归对象的。 在这个例子中， <em> y</em>  就被遍历递归对象
<em> T</em> 。</p>

<p> 和递归定义一样，递归证明也分为基础范例和进阶范例。

<ul>

<li>在基础范例中，定理的证明是通过把递归变量实例化为数学对象中的一种基础范例的值。在我们的例子中，对象的定义中只有一个基础范例，因此<em> y</em>  就被初始化为
<em> C<sub>a</sub>(u,v)</em> 。 于是我们就有了这定理的特殊值得案例:
<p><center> <strong>The base case:</strong><em>  f<sub>&#945</sub>(C<sub>a</sub>(u,v),f<sub>&#945</sub>(x,z)) = f<sub>&#945</sub>(x,f<sub>&#945</sub>(C<sub>a</sub>(u,v),z)) </em> 。</center></p></li>

<li>在进阶范例中，首先假设对于归纳变量，定理成立，这被称为<em> 归纳假设</em> 。然后证明对于把归纳变量实例化为数学对象的进阶案例的值，也是成立的。这被称为<em> 归纳结论</em> 。 在证明过程中，我们被允许使用归纳假设。
在我们的例子中，只有一个进阶范例。在该归纳结论中，<em> y</em>  被实例化为
<em> C<sub>b</sub>(y)</em> 。于是我们假设

<p><center> <strong>The induction hypothesis:</strong>  <em>  f<sub>&#945</sub>(y,f<sub>&#945</sub>(x,z)) = f<sub>&#945</sub>(x,f<sub>&#945</sub>(y,z)) </em> </center></p>

<p>来证明：</p>

<p><center> <strong>The induction conclusion:</strong> <em>  f<sub>&#945</sub>(C<sub>b</sub>(y),f<sub>&#945</sub>(x,z)) = f<sub>&#945</sub>(x,f<sub>&#945</sub>(C<sub>b</sub>(y),z)) </em> 。</center></p></li>
</ul>

<p> 咋一看来，归纳法看起来也是死循环逻辑。在证明的过程中<em> 假设结论成立</em>  然而，归纳法也是螺旋型的。我们从证明螺旋的中心成立（基础范例）开始，然后进阶范例证明往外一圈的螺旋也成立，直到任意圈数的螺旋。</p>

<p> <strong>基础范例</strong>可以同时使用函数的基础范例<a href="#functions">递归定义<em> f<sub>&#945</sub></em> </a>， 即<em>  f<sub>&#945</sub>(C<sub>a</sub>(u,v),w) = w </em> 来完成。如下所示，通过两次转换来完成: </p>

<p><center><em>  f<sub>&#945</sub>(C<sub>a</sub>(u,v),f<sub>&#945</sub>(x,z)) = f<sub>&#945</sub>(x,f<sub>&#945</sub>(C<sub>a</sub>(u,v),z)) </em> 。</center></p>

<p><center> <em>  f<sub>&#945</sub>(x,z) = f<sub>&#945</sub>(x,f<sub>&#945</sub>(C<sub>a</sub>(u,v),z)) </em> </center></p>

<p><center> <em>  f<sub>&#945</sub>(x,z) = f<sub>&#945</sub>(x,z) </em> </center></p>

<p> 此时，等式的左右边相等，证明结束。</p>

<p> 在 <strong>进阶范例</strong>， 归纳结论可以通过如下方法来证明</p>
<ul>
<li> 使用两次函数的进阶范例的<a href="#functions">递归定义<em> f<sub>&#945</sub></em> </a>，即  <em>  f<sub>&#945</sub>(C<sub>b</sub>(y),v) = C<sub>b</sub>(f<sub>&#945</sub>(y,v)) </em> ; </li>
<li> 一次该等式的变化形式， 即<em>  f<sub>&#945</sub>(u,C<sub>b</sub>(v)) = C<sub>b</sub>(f<sub>&#945</sub>(u,v)) </em> ， 在使用该等式前必须先证明该引理。</li>
<li> 使用一次归纳假设
</ul>
<p>归纳结论的换写分为三个阶段： </p>

<p><center> <em>  f<sub>&#945</sub>(C<sub>b</sub>(y),f<sub>&#945</sub>(x,z)) = f<sub>&#945</sub>(x,f<sub>&#945</sub>(C<sub>b</sub>(y),z)) </em> 。</center></p>

<p><center><em>  C<sub>b</sub>(f<sub>&#945</sub>(y,f<sub>&#945</sub>(x,z))) = f<sub>&#945</sub>(x,f<sub>&#945</sub>(C<sub>b</sub>(y),z)) </em> 。</center></p>

<p><center><em>  C<sub>b</sub>(f<sub>&#945</sub>(y,f<sub>&#945</sub>(x,z))) = f<sub>&#945</sub>(x,C<sub>b</sub>(f<sub>&#945</sub>(y,z))) </em> 。</center></p>

<p><center><em>  C<sub>b</sub>(f<sub>&#945</sub>(y,f<sub>&#945</sub>(x,z))) = C<sub>b</sub>(f<sub>&#945</sub>(x,f<sub>&#945</sub>(y,z))) </em> 。</center></p>

<p>现在可以使用归纳假设来改写等号左边:

<p><center><em>  C<sub>b</sub>(f<sub>&#945</sub>(x,f<sub>&#945</sub>(y,z))) = C<sub>b</sub>(f<sub>&#945</sub>(x,f<sub>&#945</sub>(y,z))) </em> 。</center></p>

<p> 此时，等式的左右边已经完全相等，而引理也已经在先前被TheoryMine证明了，该引理名叫<em>  The Richard Scott Russell Theorem </em> 。至于证明的具体细节就留给读者了。 </p>',
	'certex_q6' => '小变化 大不同',
	'certex_a6' => '<p><a href="#data-type">四色数</a> 描述了无限多种可能的新的数学对象的其中一种可能。通过选用不同的不同基础范例和进阶范例并传入不同的值，我们可以得到不同的对象。例如，我们给<em> C<sub>a</sub></em>  只传入一个布尔类型的参数。</p>

<p><center><em>  T = C<sub>a</sub>(B) | C<sub>b</sub>(T) </em> </center></p>

<p>此时就只有两种 0s，即数值只有两种颜色。</p>

<p>或者，我们可以有两个基础范例。</p>

<p><center><em>  T = C<sub>a</sub>(B,B) | C<sub>a\'</sub>(B,B) | C<sub>b</sub>(T) </em> </center></p>

<p>现在我们有8种 0s，即8种颜色。</p>

<p>又或者我们传入一个自然数作为参数</p>

<p><center><em>  T = C<sub>a</sub>(N) | C<sub>b</sub>(T) </em> </center></p>

<p>现在我们有无限多种0s， 即无限多种颜色。</p>

<p> 这会变得越来越有趣，当我们尝试着添加进阶范例的参数。</p>

<p><center><em>  T = C<sub>a</sub>(B,B) | C<sub>b</sub>(T,N) </em> </center></p>

<p>现在我们可以有无限多种后继函数。另一种视角是，试想，定理自然数序列，例如数字被后继函数联系在一起。因此<em> C<sub>b</sub>(C<sub>b</sub>(C<sub>b</sub>(C<sub>a</sub>(true,true),1),3),2)</em>  就会是 <span
style="color:#FF0000">1,3,2</span>。</p>

<p> 而且我们不必局限于 <em> B</em>  and <em> N</em> 作为输入参数。在 <em> T</em> 的已被定义的前提下, 我们甚至还可以用它作为输入参数来构造一些新的对象<em> T\'</em> , </p>

<p><center><em>  T\' = C<sub>a</sub> | C<sub>b</sub>(T\',T) </em> </center></p>

<p>于是就有了不同颜色的序列。  <span
style="color:#FF0000">1</span>, <span
style="color:#00FF00">3</span>, <span
style="color:#0000FF">2</span>。 </p>',
	'certex_glossary_title' => '术语表',
	'certex_glossary' => '<p>我们收集了一些专业术语的定义，解释，及其同义词，一些术语在数学和计算机领域有着特殊的含义。 <p>

<ul>

<li><strong>数学公理:</strong> 是用在数学证明中，从已知的定理推导出新的定理的数学表达式。他们被假设为正确的。在TheoryMine的证明中，唯一使用的数学公理为通过递归来定义的函数的定义。 </li>

<li><strong>布尔类型:</strong> 是真值得集合: <em> true</em>  and <em> false</em> 。 </li>

<li><strong>构造函数:</strong> 是以递归方式来定义数学对象的函数。</li>

<li><strong>已定义函数:</strong> 转换一个到多个输入为一个输出。在计算机专业他们也被称为 <em> 程序</em>  。而这种我们用的这种递归形式的已定义函数被称为<em> 函数程序</em> 。 </li>

<li><strong>归纳法:</strong> 是一种证明的形式，该形式使用先前的定理的实例作为假设来证明其后的定理的实例。先前的实例是被定义的well-founded的递归序列。这种归纳法被称为<em> 数学归纳法</em> ， 实质上是一种不具有不确定性的<em> 推导</em>。和 <a href="http://www.newworldencyclopedia.org/entry/Induction_%28philosophy%29#Enumerative_induction">枚举归纳法</a> 不同, 枚举归纳法是一种从有限实例的集合中推测或者总结出出规律的通用方法，和数学归纳法不同，这种归纳法是不确定的和可能出错的。
</li>

<li><strong>归纳结论:</strong> 在归纳证明中被证明的定理的实例。</li>

<li><strong>归纳假设:</strong> 在归纳证明中假设为成立的定理的实例。</li>

<li><strong>输入:</strong>  传入给已定义函数或者构造函数的值，它们也被称为<em> 参数</em> 。</li>

<li><strong>输出:</strong> 已定义函数或者构造函数返回的值，它们也被称为<em> 返回值</em> 。</li>

<li><strong>数学对象:</strong> 能够作为已定义函数或者构造函数的输入或者输出的值得集合。在计算机领域，它们也被称为<em> 数据结构</em> , <em> 数据类型</em>  或者<em> 类型</em> 。</li>

<li><strong>自然数:</strong> 非负的整数集合: <em> 0, 1, 2, 3, ....</em> </li>

<li><strong>证明:</strong> 是在证明定理时推理的序列。每一个推理的步骤可以是一个公理或者遵循某些逻辑的先前公理证明序列中后续。</li>

<li><strong>递归:</strong> 一种定义已定义函数或者构造函数的方式，被定义主体出现在定义表达式中。</li>

<li><strong>数学定理</strong> 是已被证明的数学公式。一个数学定理如果被用于推导其他公理，此刻就被称为<em> 引理</em> 。如果一条数学定理是紧接着另一条公理推导出来的话，它就被称为<em> 推论</em> 。有时数学公理也被称为<em> 命题</em> 。 </li>

<li><strong>数学理论</strong> 是数学对象和相关函数的集合。它们间接地定义了定理的集合，因此理论有时也被认为是定理的集合。

</ul>',

	//success

	'success' => '<h1> 恭喜您! </h1><p>您的订单已成功！<p/><p> 我们的机器数学家正在奋力的未您的定理工作这，通常这需要48小时。 </p><p>当您的定理就绪的时候，您将收到一封确认信。<br/></p>',

	//unlock

	'unlock_title'=> '账户被锁定',
	'unlock_success' => '  您的账户 已被解锁，现在您可以',
	'unlock_login' => '您已经登录，在解锁前您需要 <a href="?go=logout">退出</a>',
	'unlock_failed1' => '<h2> 账户解锁失败！ </h2><p> 您的账户可能没有被锁定，或者在您访问解锁链接后又再次被锁定了。</p> <p> 如果您的账号未被锁定，您只需要直接',
	'unlock_failed2' => '否则请查看您的邮件。如果您已经忘记了密码，您可以',
	'unlock_failed3' => ' 申请更换密码',

	//report_name

	'repotname_title' => '恶意命名举报： ',
	'repotname_q1' => '您认为该名字是恶意的原因：',
	'repotname_q2' => '您的邮箱地址:',
	'repotname_button' => '举报',

	//change_pass

	'changepass_invalid' => '您输入的邮件地址无效。</span> 可能这是一个已经失效的申请。如果您想改变您的密码，请在下面输入您的邮箱地址，并点击“申请更换密码”按钮。',
	'changepass_emailsent1' => '邮件已经被发送到 ',
	'changepass_emailsent2' => ' 该邮件中包含了能够更换密码的链接。</p> <p><span class=good>您现在可以确认您的邮件了</span>。</p> <p>如果您记得您的旧密码，您可以忽略该邮件, 并和往常一样',
	'changepass_passchanged' => '更换密码成功',
	'changepass_login' => '您现在可以 登录',
	'changepass_return' => '<div class="backarrow"><a href="?">返回综述</a></div> <div class="backarrow"><a href="?go=profile">返回账户</a></div>',
	'changepass_blankpass' => '您必须输入空白密码!',
	'changepass_doit' => '现在您可以变更您的密码。',
	'changepass_newpass' => '请输入新的密码:',
	'changepass_returnlogin' => '返回登录页面',
	'changepass_title' => '您能在该页面申请变更您的密码。',
	'changepass_p' => '在您提交变更密码的申请后，您将收到我们发送的一封邮件，该邮件中包含了能够更换密码的链接。</p><p> 如果您记得您的旧密码，您可以忽略该邮件, 并和往常一样 ',
	'changepass_loginasnormal' => '登录',
	'changepass_enteremail' => '请输入您TheoryMine的用户名:',
	 'changepass_requestpass' => '申请更换密码',


	//gadgets

	'gadgets_title' => '礼品为: ',
	'gadgets_p1' => '您现在可以购买到TheroyMine的T恤，鼠标垫以及马克杯！<br>所有的礼品都由 <a href="http://www.zazzle.com/"  target="_blank">Zazzle</a>提供，且有您的定理的个性化定制。',
	'gadgets_p2' => '您可以选择您所在地的国家或者离您所在地最近的国家，这样您就可以节省邮费。同时您也可以访问TheoryMine的礼品商店来购买与您的定理相关的个性化商品。 选择不同的款式，颜色以及大小并个性化您的商品！',
	'gadgets_p3' => '欲了解更多详情请参阅 <a href="http://www.zazzle.com"  target="_blank">Zazzle</a> ，以及他们的 <a href="http://www.zazzle.co.uk/mk/policy/user_agreement" target="_blank">用户协议</a> 和 <a href="http://www.zazzle.co.uk/mk/policy/privacy_policy"  target="_blank">隐私协议</a>。',
	'gadgets_wherefrom' => '请选择您想要您的产品从哪个国家寄出:',
	'gadgets_selection' => '您已选择:',
	'gadgets_go' => '看看商店！',
		'gadgets_northamerica' => "北美",
	'gadgets_canada'=>	"加拿大",
	'gadgets_usa'=> "美国",
	'gadgets_europe' => "欧洲",
	'gadgets_austria' => "奥地利",
	'gadgets_belgium'=> "比利时",
	'gadget_france'=> "法国",
	'gadgets_germany'=> "德国",
	'gadgets_netherlands' => "荷兰",
	'gadgets_portugal'	=> "葡萄牙",
	'gadgets_spain'	=> "西班牙",
	'gadgets_sweden' => "瑞典",
	'gadgets_swiz' => "瑞士",
	'gadgets_uk' => "英国",
	'gadgets_asia' => "亚洲/太平洋",
	'gadgets_australia' => "澳大利亚",
	'gadgets_japan' => "日本",
	'gadgets_newz' => "新西兰",
	'gadgets_latin' => "拉丁美洲",
	'gadgets_brazil'=> "巴西",
	'gadgets_other' => "其他国家",

	//login

	'login_title' => '登录TheoryMine系统',
	'login_failed' => '<span class="warning">登录失败</span>, 请确认您的邮箱地址/登录名并重新输入密码。</p><p>如果您忘记了密码，可以点击来申请 ',
	'login_resetpassword' => '重设密码',
	'login_waiting_email' => '<span class="warning">请查看您的邮件</span>， 邮件中有能授权您登录的链接。 <p>这可能由于该邮箱地址是新注册的，或因为您更换了一个邮箱地址。<p> 如果您未收到我们发送的邮件，请点击<a href="?go=change_pass">申请更换密码</a> 来继续。',
	'login_noaccount' => '未注册用户? ',
	'login_pass_forgot' => '忘记您的密码?',

	//register

	'register_title' => '注册TheoryMine',
	'register_p1' => '注册成为TheoryMine的会员来获得我们产品的实时资讯（例如，和您定理相关的T恤和鼠标垫，甚至的在线期刊！），同时可以查看您的定理和其他人的定理的联系。',
	'register_missing_entry' => '请您填写带*好的项目并重新输入您的密码。',
	'register_mismatch' => '您的密码不一致，请重新输入。',
	'register_privacy' => '关于我们如何处理个人信息的条款请访问 <a href="?go=privacy">这里 </a>',
	'register_retype1' => '重新输入密码',
	'register_retype2' => '请重新输入密码',
	'register_nearly' => '非常感谢您的注册，我们已经把用于完成注册的邮件发送到：',
	'register_checkemail' => '接下来请您检查您的邮箱，在我们发给您的邮件中包含一个链接，该链接用于为您的帐号解锁并完成注册。',

	//profile

	'profile_login' => '您需要 <a href="?go=login">登录</a>',
	'profile_enterpass' => '您需要输入密码来更新您的具体信息。',
	'profile_wrongpass' => '您输入的密码不正确，请您再次输入。 ',
	'profile_edit' => '编辑具体信息：',
	'profile_needto' => '请输入',
	'profile_good' => '更新成功',
	'profile_return' => '返回主页',
	'profile_details' => '您的具体信息:',
	'profile_changepass' => '(你也可以重置密码)',

	//contact

	'contact_title' => '联系我们',

	//logout
	 'logout' => '您已经退出登录',


	///*******COMMON PARTS*************///

	//dicovered_theorems

	'dicoveredthm_one' => '您已经命名了一个数学定理:',
	'dicoveredthm_younamed'  => '您已经命名了  ',
	'dicoveredthm_viewcert' => '查看证书',
	'dicoveredthm_viewbro' => ' 查看手册',
	'dicoveredthm_shop' => '礼品中心',

	//dicoveries-in-progress

	'progress_none' => '您没有正在处理的定理请求，您是否想<a href="?go=discover">命名一个定理</a>？',
	'progress_one' => '您有一个请求正在处理:',
	'progress_youhave' => '您有 ',
	'progress_ndisc' => ' 请求正在处理中',
	'progress_placedon' => '该订单于 ',
	'progress_ordid' => ' 确认并有订单号: ',

	//footer

	'footer_tc' => '条款和条例',
	'footer_contact' => '联系我们',
	'footer_privacy' => '隐私条例',
	'footer_cancellations' => '取消订单',
	'footer_questions' => '对TheoryMine有疑问？请发送电子邮件到 ',

	//header

	'header_tagline' => '个性化的数学定理',
	'header_next' => '您将有机会成为下一位!',
	'header_new' => '好消息!</font> <br/>您现在可以购买到 <a href="?go=products#gift_items">TheoryMine的T恤，鼠标垫和马克杯了！</a>',
	'header_clear' => '清空消息',

	//main_links_header

	'links_loggedin' => '登录为 ',
	'links_profile' => '个人账户',
	'links_logout' => '退出',
	'links_login' => '登录',
	'links_home' => '主页',
	'links_disc' => '命名定理',
	'links_faq' => '常见问答',
	'links_about' => '关于我们',
	'links_gift' => '礼品中心',
	'links_test' => '见证',

	//question-mark

	'questionmark' => '这个名字将永远和您的定理联系在一起。 <br/> 名字可以是人名，昵称或者任何符合如下要求的称呼:<br/><br/> - &nbsp 不得长于30个字。<br/> - &nbsp 不能是不适当的，中伤，诽谤，亵渎的，淫秽的，攻击公共道德的或种族仇恨或具有恐怖主义煽动性的 <br/><br/> 定理的名字会经过审查，如果被发现或者举报该名字是不恰当的，他们将被从系统中移除并不提供任何补偿。',

	///*******EMAIL*************///

	//email_footer

	'emailfooter_regards' => '来自TheoryMine的敬意',
	'emailfooter_emailus' => '该邮件有TheoryMine发送 <a href="http://www.theorymine.co.uk/">http://www.theorymine.co.uk/</a><br> 对我们有任何疑问？请发通过 ',
	'emailfooter_please' => '联系我们。<br>请',
	'emailfooter_unsuscribe' => '发邮件</a>给我们如果您想退订我们的资讯。',



  //general

  'login' => '登录',
  'faq' => '参阅常见问题',
  'letusknow' => '告知我们',
  'register' => '注册新用户',
  'theorems' => '个数学定理:',
  'email' => '邮箱地址',
  'firstname' => '名',
  'lastname' => '姓',
  'cancel' => '取消',
  'password' => ' 密码:',
  'select'=> '选择',
  'edit_details' => '编辑个人信息',
  'change_password' => '重置密码',
  'update' => "更新我的个人信息",




);


?>
