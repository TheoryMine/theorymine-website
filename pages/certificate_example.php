<?
$here_link = "?go=certificate_example";
$header_title = "Example Certificate";
include 'pages/common_parts/header.php';
?>

 
<center> 
 <h1><!--An Example Certificate Explained--><?print$thislang['certex_title'];?></h1>

<p>
<!--The following is an example of a certificate generated by TheoryMine. An explanation of a formula can be obtained by clicking on it.--><?print $thislang['certex_p1'];?> 
</p>

<img src="images/Quentins_Theorem.jpg" alt="An Example Certificate" border=0 usemap="#imagemap"> 

<map name="imagemap">
<area shape=rect coords="100,250,400,300" href="#data-type">
<area shape=rect coords="100,320,400,420" href="#functions">
<area shape=rect coords="100,460,500,600" href="#theorem">
</map>


<br> 
</center> 
<br/><br/> 
 
<h2 id="overview"><!--What does it mean? A quick overview--><?print $thislang['certex_q1'];?> </h2>

<!--<p> This particular theorem was created in honour of Quentin Cooper,
who interviewed us for the BBC Radio 4 science magazine programme
Material World on 15th April 2010. The certificate above is different
from the one originally presented  to Quentin. We have
updated it into the format of the certificates we currently issue to
customers.  In particular, we have now standardised the way we name
the various mathematical expressions.  </p>

<p> Following the name of the theorem, <em>Quentin's Theorem</em>, the
certificate contains, in turn: the definition of a new kind of
mathematical object, <em>T</em>; the definition of a new mathematical
function, <em>f<sub>&#945</sub></em>; and the statement of the theorem.</p>

<p> One way to envisage <em>T</em> is as four copies of the
non-negative whole numbers 0, 1, 2, 3, ..., each copy in a different
colour, say red, blue, green and yellow: <span
style="color:#FF0000">0, 1, 2, 3, ...</span>, <span
style="color:#0000FF">0, 1, 2, 3, ...</span>, etc.  So each member of
<em>T</em> has both a numerical value and a colour.  <em>f<sub>&#945</sub></em>
is then a kind of addition on these numbers. Its inputs are two
coloured numbers and its output is a third coloured number, whose
numerical value is the sum of those of the inputs and whose colour is
that of the <em>second</em> input.</p>

<p> Note that, unlike regular addition, <em>f<sub>&#945</sub></em> is not
commutative, that is its output depends on the <em>order</em> of its
inputs. For instance, 
<em>f<sub>&#945</sub>(<span style="color:#FF0000">1</span>, <span style="color:#0000FF">2</span>)=
<span style="color:#0000FF">3</span></em> but 
<em>f<sub>&#945</sub>(<span style="color:#0000FF">2</span>, <span style="color:#FF0000">1</span>)=
<span style="color:#FF0000">3</span></em>. 
Notice that the numerical values
of the outputs are the same, but the colours are different, as they
depend on the colour of the second input.</p>

<p> However, if we add three coloured numbers together, then the order
of the first two is immaterial. This is because the colour of the
output will be that of the third input, so will not depend on the
colours of the first two inputs. For instance,
<em>
f<sub>&#945</sub>(<span style="color:#FF0000">1</span>, 
	f<sub>&#945</sub>(<span style="color:#0000FF">2</span>,<span style="color:#00FF00">3</span>)) =
f<sub>&#945</sub>(<span style="color:#0000FF">2</span>, 
	f<sub>&#945</sub>(<span style="color:#FF0000">1</span>,<span style="color:#00FF00">3</span>))
</em> since both sides equal <span style="color:#00FF00">6</span>.
The generalisation of this equality is Quentin's Theorem, i.e., it is
a restricted variant of commutativity.</p><p> We now give a more technical explanation of the certificate. The technical
terms used in this explanation are also defined in the <a href="#glossary">glossary</a> at the end.</p>-->
<?print $thislang['certex_a1'];?> 

<h2 id="recursion"><!--A bluffer's guide to recursion--><?print $thislang['certex_q2'];?> </h2>

<!--<p> Both <em>T</em> and <em>f<sub>&#945</sub></em> are defined by
<em>recursion</em>. This is a form of definition in which the body of
the definition contains the thing being defined. This sounds circular,
but it need not be. Consider, the following recursive definition of
the, so called, <em>natural numbers</em>, i.e., the non-negative whole
numbers 0, 1, 2, 3, .... </p>

<p><center><em> N = 0 | s(N) </em></center></p>

<p> where <em>s</em> is called the <em>successor function</em>. This definition
generates a representation of the natural numbers of the form <em>0, s(0),
s(s(0)), s(s(s(0))), ...</em>, where each application of <em>s</em> increases
the number by 1. This representation is due to the mathematician <a
href="http://en.wikipedia.org/wiki/Peano_axioms">Giuseppe Peano
(1858-1932)</a>. The recursive definition consists of two cases: a base case
<em>0</em> and a step case <em>s(N)</em>. Any particular natural number
corresponds to one of these cases.  Note that the step case contains <em>N</em>,
which is the thing being defined. Think of this, not as a circle, but as a
spiral.  <em>0</em> is at the centre of the spiral; each application of
<em>s</em> winds the spiral out by a complete circuit. <em>0</em> and <em>s</em>
are called <em>constructor functions</em>, because they are used to construct
new types of mathematical objects, such as our four-coloured numbers. Note that
constructor functions are <em>deliberately</em> not defined. They are taken as
primitive mathematical objects and are used in the definitions of other
mathematical objects and defined functions, such as +. Definitions have to stop
unfolding at some point, and that point is with the constructor functions. </p>

<p> The boolean truth values, <em>true</em> and <em>false</em>, can be
defined by a degenerate form of recursion, in which there are two base
cases and no step cases: <em>B = true | false</em>. </p>

<p> We will use <em>B</em> and <em>N</em> as the basis for defining
new sets of recursively defined mathematical objects, such as
<em>T</em> in our example certificate above. </p>

<p> The function <em>+</em> can also be defined recursively. It takes
two members of <em>N</em> as inputs and returns one as output.  It
also has a base case and a step case.</p>

<p><center><strong>Type:</strong> <em> + : N &times; N &rarr; N </em> </center></p>
<p><center><strong>Base case:</strong> <em> 0+y = y </em></center></p>
<p><center><strong>Step case:</strong> <em> s(x)+y = s(x+y) </em> </center></p>

<p> The type line says that + takes two natural numbers as inputs and outputs
one natural number. The base case and step case lines constitute the recursive
definition of +.  The recursion is on <em>x</em>, the first input of +. Note
that, in the step case, the body of the definition also contains +, the function
being defined. This is also not a circular definition, but a spiral one. This
time the recursion spirals inwards. Starting with some particular value
of <em>x</em>, say <em>s(s(o))</em>, the step case is applied to
rewrite <em>s(s(0))+y</em> first to <em>s(s(0)+y)</em> and then to
<em>s(s(0+y))</em>. Now the base case of the definition can be used to rewrite
this as <em>s(s(y))</em> and the calculation is finished. Notice how the step
case is organised so that + is applied to a smaller occurrence of <em>x</em> in
the body of the definition than in the head. <em>N</em> has been defined to be
<em>well founded</em>, which means that a sequence of its members cannot keep
getting smaller forever: sooner or later it will reach 0. This means that any
calculation carried out using + will eventually stop. We can only apply the step
case a finite number of times. Eventually, only the base case will be applicable
and, after the base case, nothing will be applicable. To contrast functions such
as + with the constructor functions, such as 0 and <em>s</em>, + is called a
<em>defined function</em>. </p>--><?print $thislang['certex_a2'];?> 


<h2 id="data-type"><!--Defining four-coloured numbers--><?print $thislang['certex_q3'];?> </h2>

<!--<p>Our certificate introduces a new type of mathematical object
called <em>T</em>, our four-coloured numbers. <em>T</em> is defined
<a href="#recursion">recursively</a> as:</p>

<p><center><em> T = C<sub>a</sub>(B,B) | C<sub>b</sub>(T) </em></center></p>

<p> where <em>C<sub>a</sub></em> and <em>C<sub>b</sub></em> are new constructor functions. 
<em> C<sub>a</sub></em> is a base constructor, since it does not have <em>T</em>
among its inputs. It is analogous to the 0 constructor function of
<em>N</em>, except that it has two inputs. These inputs are both
members of <em>B</em>, i.e., they are one of two truth values:
<em>true</em> and <em>false</em>. There are, therefore, four ways to
instantiate <em>C<sub>a</sub></em>: <em>C<sub>a</sub>(true,true)</em>,
<em>C<sub>a</sub>(true,false)</em>, <em>C<sub>a</sub>(false,true)</em> and
<em>C<sub>a</sub>(false,false)</em>, i.e., there are four versions of 0. Above
we envisaged these four versions of 0 as four differently coloured 0s,
e.g., <em>C<sub>a</sub>(true,true)</em> could be envisaged as <span
style="color:#FF0000">0</span> and <em>C<sub>a</sub>(true,false)</em> as
<span style="color:#0000FF">0</span>. </p>

<p> <em>C<sub>b</sub></em> is a step constructor, since it does have <em>T</em>
among its inputs. It is analogous to the <em>s</em> constructor
function of <em>N</em>. The main difference to <em>s</em> is that
<em>C<sub>b</sub></em> can be applied to four different kinds of base
constructor. We can envisage these <em>C<sub>b</sub></em> applications as colour
preserving. For instance, since <em>C<sub>b</sub>(C<sub>b</sub>(C<sub>a</sub>(true,true)))</em> has
a <span
style="color:#FF0000">0</span> at its heart, we can envisage it as <span
style="color:#FF0000">2</span>.</p>

<p> Note that, just as with <em>0</em>, <em>s</em>, <em>true</em> and
<em>false</em>, the new constructor functions, <em>C<sub>a</sub></em> and
<em>C<sub>b</sub></em> are undefined primitives.</p>--><?print $thislang['certex_a3'];?> 


<h2 id="functions"><!--Defining four-coloured addition--><?print $thislang['certex_q4'];?> </h2>

<!--<em>f<sub>&#945</sub></em> is a <a href="#recursion">recursively</a> defined function, whose definition is:</p>

<p><center><strong>Type:</strong> <em> f<sub>&#945</sub> : T &times; T &rarr; T </em> </center></p>
<p><center><strong>Base case:</strong> <em> f<sub>&#945</sub>(C<sub>a</sub>(x,y),z) = z </em> </center></p>
<p><center><strong>Step case:</strong> <em> f<sub>&#945</sub>(C<sub>b</sub>(x),y) = C<sub>b</sub>(f<sub>&#945</sub>(x,y)) </em> </center></p>
</ul>

<p> Compare this definition to that of + above. It's essentially the
same. <em>f<sub>&#945</sub></em> is just a version of addition.</p>

<p> To see why each output of <em>f<sub>&#945</sub></em> has the same
colour as its second input, consider first the base case. The first
input of <em>f<sub>&#945</sub></em> is one of the coloured 0s,
<em>C<sub>a</sub>(x,y)</em>, but regardless of its colour, the output
is its second input, <em>z</em>, so it necessarily has the
same colour as this second input. </p>

<p> Now consider the step case of the definition of
<em>f<sub>&#945</sub></em>. Assume that we have already inferred that
the output of <em>f<sub>&#945</sub>(x,y)</em> has the same colour as
its second input <em>y</em>. Since <em>C<sub>b</sub></em> is colour
preserving, then <em>f<sub>&#945</sub>(C<sub>b</sub>(x),y)</em> also
has the same colour as <em>y</em>, which is its second input. In this
way, starting from the situation when <em>f<sub>&#945</sub></em> has
first input <em>C<sub>a</sub>(x,y)</em>, we can incrementally spiral
out showing that the argument holds for each application of
<em>C<sub>b</sub></em> and, therefore, for every member of
<em>T</em>. This is called an <em>inductive proof</em>. It is the same
kind of reasoning that TheoryMine uses to prove all the theorems that
it generates. </p>.--><?print $thislang['certex_a4'];?>


<h2 id="theorem"><!--Proving Quentin's Theorem--><?print $thislang['certex_q5'];?></h2>

<!--<p> On the certificate, Quentin's Theorem is said to be proved by "induction on <em>y</em>". What does this mean? </p>

<p> <em>Induction</em> is closely related to <a
href="#recursion">recursion</a>. Theorems composed of <a
href="#functions">recursively defined functions</a> applied to <a
href="#data-type">recursively defined objects</a>, such as Quentin's theorem, are
usually proved by induction.  Firstly, an induction variable is chosen.  In this
case it is <em>y</em> - although, as Quentin's Theorem is symmetric with
respect to <em>x</em> and <em>y</em>, it could equally well have been
<em>x</em>. The induction variable will range over some recursively defined
mathematical object. In our case, <em>y</em> ranges over objects of type
<em>T</em>.</p>

<p> Just like a recursive definition, an inductive proof is divided into
base and step cases.

<ul>

<li>In the base cases, the theorem is proved with the induction variable being
instantiated to the base case of the mathematical objects it ranges over. In our
case, there is only one base case, in which <em>y</em> is instantiated to
<em>C<sub>a</sub>(u,v)</em>. So, we have to prove the special case of the
theorem:
<p><center> <strong>The base case:</strong><em> f<sub>&#945</sub>(C<sub>a</sub>(u,v),f<sub>&#945</sub>(x,z)) = f<sub>&#945</sub>(x,f<sub>&#945</sub>(C<sub>a</sub>(u,v),z)) </em>.</center></p></li>

<li>In the step cases, the theorem is assumed to hold for the induction
variable. This is called the <em>induction hypothesis</em>. The theorem is then
proved with the induction variable being instantiated to the step case of the
mathematical objects it ranges over. This is called the <em>induction
conclusion</em>. During the proof of the induction conclusion, we are allowed to use the induction hypothesis. 
In our
case, there is only one step case. In its induction conclusion,  <em>y</em> is instantiated to
<em>C<sub>b</sub>(y)</em>. So, we assume:

<p><center> <strong>The induction hypothesis:</strong>  <em> f<sub>&#945</sub>(y,f<sub>&#945</sub>(x,z)) = f<sub>&#945</sub>(x,f<sub>&#945</sub>(y,z)) </em></center></p> 

<p>and then have to prove:</p>

<p><center> <strong>The induction conclusion:</strong> <em> f<sub>&#945</sub>(C<sub>b</sub>(y),f<sub>&#945</sub>(x,z)) = f<sub>&#945</sub>(x,f<sub>&#945</sub>(C<sub>b</sub>(y),z)) </em>.</center></p></li>
</ul>

<p> At first sight, inductive proofs look circular. During the proof of the step
case, we <em>assume the theorem already holds</em>. But, once again, the
inductive proof is really spiral. We start by proving that the theorem holds for
the centre of the spiral (the base case), then the step case can be used to
prove that it holds for one circuit of the spiral, then for two circuits, then
three, and so on for any number of circuits. </p>

<p> <strong>The base case</strong> can be proved by two applications of the base case of <a href="#functions">the recursive definition of <em>f<sub>&#945</sub></em></a>, namely <em> f<sub>&#945</sub>(C<sub>a</sub>(u,v),w) = w </em>, where I have renamed the variables to avoid confusion with those in the theorem. These can be used to rewrite the base case in two stages, as follows: </p>

<p><center><em> f<sub>&#945</sub>(C<sub>a</sub>(u,v),f<sub>&#945</sub>(x,z)) = f<sub>&#945</sub>(x,f<sub>&#945</sub>(C<sub>a</sub>(u,v),z)) </em>.</center></p>

<p><center> <em> f<sub>&#945</sub>(x,z) = f<sub>&#945</sub>(x,f<sub>&#945</sub>(C<sub>a</sub>(u,v),z)) </em></center></p>

<p><center> <em> f<sub>&#945</sub>(x,z) = f<sub>&#945</sub>(x,z) </em></center></p>

<p> At this point, the equation is between two identical expressions, so the base case is proved.</p>

<p> In <strong>the step case</strong>, the induction conclusion can be proved by:</p>
<ul>
<li> two applications of the step case of <a href="#functions">the recursive definition of <em>f<sub>&#945</sub></em></a>, namely  <em> f<sub>&#945</sub>(C<sub>b</sub>(y),v) = C<sub>b</sub>(f<sub>&#945</sub>(y,v)) </em>; </li>
<li> one application of a variant of this equation, namely  <em> f<sub>&#945</sub>(u,C<sub>b</sub>(v)) = C<sub>b</sub>(f<sub>&#945</sub>(u,v)) </em>, which must be first proved as an intermediate lemma; and </li>
<li> an application of the induction hypothesis. 
</ul>
<p>The induction conclusion is rewritten in three stages, as follows: </p>

<p><center> <em> f<sub>&#945</sub>(C<sub>b</sub>(y),f<sub>&#945</sub>(x,z)) = f<sub>&#945</sub>(x,f<sub>&#945</sub>(C<sub>b</sub>(y),z)) </em>.</center></p>

<p><center><em> C<sub>b</sub>(f<sub>&#945</sub>(y,f<sub>&#945</sub>(x,z))) = f<sub>&#945</sub>(x,f<sub>&#945</sub>(C<sub>b</sub>(y),z)) </em>.</center></p>

<p><center><em> C<sub>b</sub>(f<sub>&#945</sub>(y,f<sub>&#945</sub>(x,z))) = f<sub>&#945</sub>(x,C<sub>b</sub>(f<sub>&#945</sub>(y,z))) </em>.</center></p>

<p><center><em> C<sub>b</sub>(f<sub>&#945</sub>(y,f<sub>&#945</sub>(x,z))) = C<sub>b</sub>(f<sub>&#945</sub>(x,f<sub>&#945</sub>(y,z))) </em>.</center></p>

<p>The induction hypothesis can now be used to rewrite the left hand side to:

<p><center><em> C<sub>b</sub>(f<sub>&#945</sub>(x,f<sub>&#945</sub>(y,z))) = C<sub>b</sub>(f<sub>&#945</sub>(x,f<sub>&#945</sub>(y,z))) </em>.</center></p>

<p> At which point, the equation is again between two identical expressions, so
the step case is proved. The lemma was previously proved by TheoryMine and is
called <em> The Richard Scott Russell Theorem </em>. Its proof is also by
induction and is left as an exercise for the reader. </p>--><?print $thislang['certex_a5'];?>


<h2 id="variations"><!--Variations on a theme--><?print $thislang['certex_q6'];?></h2>

<!--<p> The <a href="#data-type">four-coloured numbers</a> described above are just
one among infinitely many possible new mathematical objects. Different kinds of
objects are generated by the choice of base and step constructors and by the
inputs that we give them. For instance, suppose we had chosen to
give <em>C<sub>a</sub></em> only one boolean input.</p>

<p><center><em> T = C<sub>a</sub>(B) | C<sub>b</sub>(T) </em></center></p>

<p>Then there would only be two 0s, so the numbers would have only two colours.</p>

<p>Alternatively, we could have had two base case constructors. </p>

<p><center><em> T = C<sub>a</sub>(B,B) | C<sub>a'</sub>(B,B) | C<sub>b</sub>(T) </em></center></p>

<p>Now there would be eight 0s, so the numbers would have eight colours.</p>

<p>Or we could have given the base constructor a natural number as its input.</p>

<p><center><em> T = C<sub>a</sub>(N) | C<sub>b</sub>(T) </em></center></p>

<p>Now there would be an infinite number of 0s and so infinitely many colours of numbers.</p>

<p> It gets  more interesting if we give the step constructor additional arguments.</p>

<p><center><em> T = C<sub>a</sub>(B,B) | C<sub>b</sub>(T,N) </em></center></p>

<p>Now there are infinitely many different kinds of successor function. Another
way to think of this is as defining a sequence of natural numbers, i.e., the
numbers associated with each of the successor functions used in a
number. So, <em>C<sub>b</sub>(C<sub>b</sub>(C<sub>b</sub>(C<sub>a</sub>(true,true),1),3),2)</em> would be the sequence <span
style="color:#FF0000">1,3,2</span>, for instance. </p>

<p> Nor do we have to stick to <em>B</em> and <em>N</em> as inputs to these constructor functions. Having defined <em>T</em>, for instance, we could use it as an input to a constructor function for some new objects <em>T'</em>, </p>

<p><center><em> T' = C<sub>a</sub> | C<sub>b</sub>(T',T) </em></center></p>
 
<p> which would allow us to have sequences of differently coloured numbers:  <span
style="color:#FF0000">1</span>, <span
style="color:#00FF00">3</span>, <span
style="color:#0000FF">2</span>. </p>--><?print $thislang['certex_a6'];?>

<h2 id="glossary"><!--Glossary--><?print $thislang['certex_glossary_title'];?></h2>

<!--<p> We have collected together the definitions of some of the technical terms
used in this explanation.  These terms have alternative names in mathematics and
computer science.  We also give some of their synonyms. <p>

<ul>

<li><strong>Axioms:</strong> are the formulae that are assumed to be true in a
theory and are used in proofs to derive new theorems from old. The only axioms
used by TheoryMine are the recursive definitions of functions. </li>

<li><strong>Booleans:</strong> are the set of truth values: <em>true</em> and <em>false</em>. </li>

<li><strong>Constructor functions:</strong> are functions used to define
mathematical objects recursively. </li>

<li><strong>Defined functions:</strong> transform one or more inputs into an
output. In computer science, they are also known
as <em>programs</em>, <em>procedures</em> or <em>sub-routines</em>. In
particular, the kind of recursively defined functions we use are <em>functional
programs</em>. </li>

<li><strong>Induction:</strong> is a form of proof in which earlier instances of
the theorem are used as assumptions when proving later instances of the theorem,
where earlier and later are defined by a well-founded recursive order.  This type of induction is also called <em>mathematical induction</em>, which is a form of <em>deduction</em> with no element of uncertainty or probability. It is not to be confused with <a href="http://www.newworldencyclopedia.org/entry/Induction_%28philosophy%29#Enumerative_induction">enumerative induction</a>, in which a general rule is conjectured from a finite set of its instances. Enumerative induction, unlike mathematical induction, <em> is</em> uncertain and fallible. 
</li>

<li><strong>Induction Conclusion:</strong> is the later instance of the theorem that is proved in an inductive proof. </li>

<li><strong>Induction Hypothesis:</strong> is the earlier instance of the theorem that is assumed in an inductive proof. </li>

<li><strong>Inputs:</strong>  are the values
given to a defined or constructor function. They are also known
as <em>arguments</em> and <em>parameters</em>.</li>

<li><strong>Outputs:</strong> are the values returned by a defined or
constructor function. They are also known as <em>results</em>.</li>

<li><strong>Mathematical objects:</strong> are the set of values that can be
input to or output by a defined or constructor function. In computer science,
they are also known as <em>data-structures</em>, <em>data-types</em> or
sometimes just <em>types</em>.</li>

<li><strong>Natural numbers:</strong> are the set of non-negative integers (whole numbers): <em>0, 1, 2, 3, ....</em></li> 

<li><strong>Proofs:</strong> are the sequences of inference steps used to prove a
theorem. Each inference step is either an axiom or follows from earlier theorems
in the sequence by some rule of logic. </li>

<li><strong>Recursion:</strong> is a form of definition in which a function or
mathematical object is defined in terms of itself. </li>

<li><strong>Theorems</strong> are formulae that can be proved. A theorem used to
help prove another theorem is called a <em>lemma</em>. A theorem that follows
immediately from another one is called a <em>corollary</em>. Theorems are
sometimes also called <em>propositions</em>. </li>

<li><strong>Theories</strong> are collections of mathematical objects and
defined functions. These implicitly define a set of theorems, so 'theories' is
also sometimes used to refer to this set of theorems.

</ul>--><?print $thislang['certex_glossary'];?>
